# -*- coding: utf-8 -*-
"""Music Recommendation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X9kgN40rg9cga5OHLuGKvOIr8pG1pkpz

# Import Libarary
"""

import os
import zipfile
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import RobustScaler
from sklearn.metrics.pairwise import cosine_similarity
import warnings
warnings.filterwarnings('ignore')

"""## Import Libraries dan Setup Environment

Pada tahap ini, kita mengimport semua library yang diperlukan:
- **pandas & numpy**: Manipulasi dan analisis data
- **matplotlib & seaborn**: Visualisasi data
- **sklearn**: Machine learning tools (RobustScaler, cosine_similarity)
- **zipfile & os**: File handling untuk dataset
- **warnings**: Menyembunyikan warning yang tidak perlu

Library sklearn yang digunakan:
- `RobustScaler`: Untuk normalisasi fitur yang robust terhadap outliers
- `cosine_similarity`: Untuk menghitung kesamaan antar lagu berdasarkan audio features

# Load Dataset

Mengunggah File kaggle.json untuk authentikasi
"""

from google.colab import files
files.upload()

"""Cell ini berisi serangkaian perintah untuk mengunduh dataset dari Kaggle ke lingkungan Google Colab Anda. Ini melibatkan konfigurasi API Kaggle, pengunduhan dataset, dan ekstraksi file."""

# Buat direktori .kaggle dan pindahkan json ke sana
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/

# Ubah permission agar tidak error
!chmod 600 ~/.kaggle/kaggle.json

# Download dataset
!kaggle datasets download -d joebeachcapital/30000-spotify-songs

# Ekstrak zip
with zipfile.ZipFile("30000-spotify-songs.zip", 'r') as zip_ref:
    zip_ref.extractall("spotify_dataset")

"""Tahap ini adalah langkah penting yang mengambil file CSV yang telah diekstrak dan memuatnya ke dalam struktur data yang dapat dianalisis di Python, yaitu Pandas DataFrame."""

# Load Dataset
df = pd.read_csv('/content/spotify_dataset/spotify_songs.csv')

"""# Exploratory Data Analysis ( EDA )

Menampilkan 5 baris pertama dari dataset untuk melihat struktur dan beberapa contoh data lagu yang tersedia.
"""

df.head()

df.shape

"""- pada tahap ini saya melihat struktur data (jumlah baris dan kolom) dan mengetahui bahwa dataset tersebut memiliki 32833 baris dan 23 fitur atau kolom

tahap ini dilakukan untuk melihat Tipe data setiap kolom/fitur yang ada dalam dataset
"""

# Info kolom dan tipe data
df.info()

"""- insight : Dataset Spotify ini cukup besar dengan 32.833 lagu dan 23 fitur yang beragam, mencakup informasi deskriptif (nama, artis, playlist) dan metrik audio numerik (danceability, energy, tempo, dll.). Dataset Spotify ini cukup besar dengan 32.833 lagu dan 23 fitur yang beragam, mencakup informasi deskriptif (nama, artis, playlist) dan metrik audio numerik (danceability, energy, tempo, dll.). Mayoritas data lengkap, namun ada sejumlah kecil (5) nilai yang hilang pada nama lagu, artis, dan nama album yang perlu dipertimbangkan saat pra-pemrosesan, meskipun jumlahnya sangat kecil dan kemungkinan tidak akan berdampak signifikan pada analisis keseluruhan. Pemahaman terhadap tipe data masing-masing kolom akan sangat membantu dalam memilih metode analisis dan visualisasi yang tepat. Pemahaman terhadap tipe data masing-masing kolom akan sangat membantu dalam memilih metode analisis dan visualisasi yang tepat.

Mengecek Baris Duplikat dalam DataFrame
"""

# Menampilkan jumlah baris duplikat (seluruh kolom sama persis)
df.duplicated().sum()

"""- insight : tidak ada baris duplikat dalam data tersebut

Menampilkan jumlah nilai yang hilang (null) untuk setiap kolom.
"""

# Cek missing value
df.isnull().sum()

"""- insight : terdapat missing value di track name dan artis tetapi Karena jumlah missing values yang minim dan terisolasi pada kolom-kolom teks, penanganannya tidak perlu menjadi prioritas utama yang mendesak, tetapi tetap merupakan bagian dari pra-pemrosesan data yang baik.

Menampilkan Plot Distribusi Genre Playlist berdasarkan genre dalam dataset
"""

plt.figure(figsize=(12, 6))
df['playlist_genre'].value_counts().plot(kind='barh', color='skyblue')
plt.title("Distribusi Genre Playlist")
plt.xlabel("Jumlah Lagu")
plt.ylabel("Genre")
plt.show()

"""- insight : Genre EDM menempati posisi teratas dengan jumlah lagu terbanyak, menunjukkan bahwa genre ini sangat populer dan sering dimasukkan ke dalam playlist. Genre rap, pop, dan r&b juga memiliki jumlah lagu yang tinggi, mengindikasikan tingginya minat pendengar terhadap musik bergenre urban dan kontemporer. Sementara itu, genre latin dan rock menempati posisi terbawah dalam distribusi ini. Hal ini bisa menunjukkan bahwa genre tersebut memiliki audiens yang lebih spesifik atau lebih sedikit direpresentasikan dalam playlist yang ada. Secara umum, distribusi ini mencerminkan preferensi musik yang lebih modern dan energik di antara pengguna."""

# Ambil kolom numerik utama
audio_features = [
    'danceability', 'energy', 'valence', 'tempo',
    'acousticness', 'instrumentalness', 'liveness', 'speechiness'
]

plt.figure(figsize=(10, 8))
sns.heatmap(df[audio_features].corr(), annot=True, cmap='coolwarm')
plt.title("Korelasi Antar Audio Features")
plt.show()

"""-  Heatmap ini memberikan pemahaman yang jelas tentang bagaimana berbagai karakteristik audio dalam dataset saling berhubungan. Hubungan yang paling menonjol adalah trade-off antara energy dan acousticness, yang secara intuitif masuk akal. Korelasi lainnya sebagian besar lemah hingga moderat, menunjukkan bahwa fitur-fitur ini memberikan informasi yang unik dan relevan untuk analisis lagu. Informasi ini sangat berguna untuk langkah-langkah selanjutnya seperti rekayasa fitur (feature engineering), pemilihan fitur (feature selection), atau pemahaman bagaimana atribut-atribut ini memengaruhi preferensi pendengar atau pengelompokan lagu.

# Data Preprocessing

Tahap ini adalah pemilihan fitur (feature selection). Dalam tahap ini, kita secara eksplisit mendefinisikan daftar kolom (fitur) dari DataFrame yang akan digunakan untuk analisis atau pemodelan selanjutnya.
"""

# Fitur yang digunakan
features = ['danceability', 'energy', 'loudness', 'speechiness', 'acousticness',
            'instrumentalness', 'liveness', 'valence', 'tempo', 'track_popularity']

"""Menghapus data yang memiliki missing values pada fitur tersebut"""

# Hapus data yang memiliki missing values pada fitur tersebut
df = df.dropna(subset=features)

"""Menghapus duplikasi data yang sebelumnya kita ketahui berada di track_name dan track_artist"""

# Hilangkan duplikasi berdasarkan 'track_name' + 'track_artist'
df_unique = df.drop_duplicates(subset=['track_name', 'track_artist']).copy()

"""Tahap ini melakukan pemilihan dan penyiapan data fitur audio dari dataset lagu. Kolom yang diambil mencakup nama lagu (track_name), artis (track_artist), dan sejumlah fitur audio seperti danceability, energy, tempo, dan lainnya yang tersimpan dalam variabel features. Selanjutnya, kolom nama lagu dan artis dijadikan sebagai index melalui set_index, sehingga setiap baris dalam dataframe merepresentasikan satu lagu unik berdasarkan kombinasi nama dan artis. Hal ini bertujuan untuk memudahkan pencarian dan identifikasi lagu saat proses perhitungan kemiripan dan rekomendasi dilakukan."""

# Simpan nama lagu untuk index
df_features = df_unique[['track_name', 'track_artist'] + features].copy()
df_features.set_index(['track_name', 'track_artist'], inplace=True)

"""Tahap ini melakukan proses scaling atau penskalaan nilai-nilai fitur audio agar berada dalam rentang yang seragam. Metode yang digunakan adalah RobustScaler, yaitu teknik normalisasi yang lebih tahan terhadap outlier dibandingkan metode standar seperti MinMaxScaler atau StandardScaler. Data yang akan diskalakan adalah kolom-kolom fitur audio yang telah dipilih sebelumnya. Hasil penskalaan disimpan dalam df_scaled, yang merupakan salinan dari df_features, namun dengan nilai fitur yang telah dinormalisasi. Proses ini penting untuk memastikan bahwa tidak ada fitur yang mendominasi perhitungan jarak atau kemiripan karena perbedaan skala."""

# Scaling
scaler = RobustScaler()
df_scaled = df_features.copy()
df_scaled[features] = scaler.fit_transform(df_scaled[features])

"""### RobustScaler vs StandardScaler
**RobustScaler dipilih karena:**
- **Robust terhadap outliers**: Menggunakan median dan IQR
- **Preserves distribution shape**: Tidak mengasumsikan distribusi normal
- **Better for music data**: Audio features sering memiliki outliers natural

**Formula RobustScaler:**
X_scaled = (X - median(X)) / IQR(X)

### Impact pada Similarity Calculation:
- Semua features berkontribusi secara seimbang
- Menghindari dominasi features dengan skala besar
- Meningkatkan akurasi cosine similarity

## Data Preprocessing (Prapemrosesan)

Langkah-langkah yang dilakukan:
- Memilih subset kolom fitur yang digunakan untuk model rekomendasi.
- Menghapus baris dengan nilai kosong dan duplikat berdasarkan `track_name` dan `track_artist`.
- Menyimpan nama lagu dan artis sebagai index.
- Melakukan normalisasi fitur menggunakan `RobustScaler` untuk mengurangi dampak outlier.

# Rekomendasi Lagu

Menggunakan **Cosine Similarity** untuk mengukur kemiripan antara lagu berdasarkan fitur numerik. Nilai similarity mendekati 1 berarti sangat mirip.
"""

# Cosine similarity
similarity = pd.DataFrame(data=cosine_similarity(df_scaled[features]),
                   index=df_scaled.index,
                   columns=df_scaled.index)

"""Fungsi recommendation_system digunakan untuk memberikan rekomendasi lagu-lagu yang mirip berdasarkan input lagu tertentu, dengan opsi tambahan untuk menyaring berdasarkan artis atau genre tertentu. Fungsi ini bekerja sebagai berikut:

1. **Input dan Validasi**: Menerima input nama lagu (song_name), nama artis (artist_name), genre yang ingin difilter (genre_filter), dan jumlah rekomendasi (num). Jika nama artis tidak diberikan, fungsi akan mencocokkan nama lagu secara eksplisit untuk menemukan pasangan (lagu, artis) dalam indeks.

2. **Ambil Skor Kemiripan**: Mengambil vektor skor cosine similarity untuk lagu yang dipilih terhadap semua lagu lain, lalu mengurutkannya dari yang paling mirip. Lagu input itu sendiri dihapus dari daftar.

3. Filter Berdasarkan Genre : Jika genre_filter diberikan, hanya lagu-lagu dengan genre yang sama yang akan disertakan dalam hasil rekomendasi.

4. **Ambil Top-N Rekomendasi**: Mengambil num teratas dari hasil yang sudah difilter.

5. **Keluaran**: Mengembalikan DataFrame terformat yang menampilkan nama lagu, artis, dan skor kemiripan, lengkap dengan caption judul rekomendasi.

Fungsi ini sangat berguna dalam konteks sistem rekomendasi musik berbasis konten, karena memungkinkan pengguna mendapatkan rekomendasi lagu yang mirip secara audio dan genre.

"""

def recommendation_system(song_name, artist_name=None, genre_filter=None, num=10):
    if artist_name:
        key = (song_name, artist_name)
    else:
        # Cari pasangan (track_name, artist) berdasarkan nama lagu
        candidates = [idx for idx in similarity.index if idx[0].lower() == song_name.lower()]
        if not candidates:
            print("Lagu tidak ditemukan dalam data.")
            return
        key = candidates[0]

    if key not in similarity.index:
        print("Lagu tidak ditemukan dalam index.")
        return

    # Ambil skor kemiripan
    sim_scores = similarity.loc[key].sort_values(ascending=False)
    sim_scores = sim_scores[sim_scores.index != key]  # Hilangkan lagu itu sendiri

    if genre_filter:
        # Filter berdasarkan genre
        genre_mask = df.set_index(['track_name', 'track_artist'])['playlist_genre'] == genre_filter
        genre_index = genre_mask[genre_mask].index
        sim_scores = sim_scores[sim_scores.index.isin(genre_index)]

    # Ambil hasil top-N
    top_n = sim_scores.head(num)

    # Buat DataFrame hasil rekomendasi
    results = pd.DataFrame(top_n).reset_index()
    results.columns = ['track_name', 'track_artist', 'similarity']

    # Return dataframe agar otomatis tampil di Jupyter
    return results.style.set_caption(
        f"ðŸŽµ Rekomendasi Lagu untuk '{song_name}' oleh '{artist_name or key[1]}'"
    ).format({
        "similarity": "{:.5f}"
    })

"""Menjalankan fungsi recommendation_system() untuk menghasilkan 15 rekomendasi lagu yang mirip dengan lagu "Shape of You" oleh Ed Sheeran, dengan filter genre "pop". Fungsi ini akan mencari lagu-lagu dengan karakteristik audio serupa dalam genre yang sama, lalu menampilkan daftar lagu paling relevan berdasarkan skor kemiripan (similarity)."""

# Contoh penggunaan
recommendation_system("Shape of You", artist_name="Ed Sheeran", genre_filter="pop", num=15)

"""Insight yang diperoleh dari hasil rekomendasi ini menunjukkan bahwa sistem berhasil mengidentifikasi lagu-lagu dengan karakteristik audio yang mirip dengan **"Shape of You"** oleh Ed Sheeran, terutama dalam genre **pop**. Beberapa hal yang bisa dicatat:

1. **Kesamaan Gaya dan Suasana**: Lagu-lagu seperti Sunflower (Post Malone), Way Back Home (SHAUN), dan Starving (Hailee Steinfeld) memiliki nuansa musik pop yang santai, melodis, dan easy-listening, selaras dengan gaya Shape of You.

2. **Keberagaman Artis**: Rekomendasi tidak hanya terbatas pada lagu dari Ed Sheeran, tetapi juga mencakup artis lain dengan popularitas tinggi dan gaya musik serupa, yang menunjukkan bahwa sistem mampu memberikan variasi dalam rekomendasi namun tetap mempertahankan relevansi.

3. **Skor Kemiripan Tinggi**: Nilai similarity tertinggi mencapai **0.96**, menandakan bahwa model mengenali kemiripan yang sangat kuat dalam fitur audio antar lagu.

4. **Potensi Temuan Lagu Baru**: Lagu-lagu seperti in my miNd oleh Maty Noyes atau Gravity oleh Ralph bisa jadi belum begitu populer, namun direkomendasikan karena kemiripan yang signifikan memberikan peluang bagi pengguna untuk menemukan lagu baru yang sesuai selera.

# Evaluasi

Tahap ini melakukan evaluasi terhadap sistem rekomendasi dengan cara menghitung Precision@K. Prosesnya dimulai dengan mencari lagu berdasarkan judul dan artis, lalu mengambil daftar top-K lagu paling mirip (berdasarkan cosine similarity), dan menghitung berapa banyak dari rekomendasi tersebut yang memiliki genre yang sama dengan lagu awal. Nilai precision ini memberikan gambaran seberapa relevan rekomendasi berdasarkan genre lagu yang diinputkan.
"""

def evaluate_recommendation(song_name, artist_name, top_k=10):
    key = (song_name, artist_name)
    if key not in similarity.index:
        print("Lagu tidak ditemukan.")
        return

    genre_asli = df.set_index(['track_name', 'track_artist']).loc[key]['playlist_genre']

    if isinstance(genre_asli, pd.Series):
        genre_asli = genre_asli.iloc[0]

    sim_scores = similarity.loc[key].sort_values(ascending=False)
    sim_scores = sim_scores[sim_scores.index != key]

    # Ambil hanya top_k rekomendasi unik
    top_recs = pd.Index(sim_scores.index).drop_duplicates().tolist()[:top_k]

    # Ambil genre untuk masing-masing rekomendasi
    try:
        genres_recs = df.set_index(['track_name', 'track_artist']).loc[top_recs]['playlist_genre']
    except KeyError:
        print("Beberapa lagu rekomendasi tidak ditemukan dalam dataset.")
        return

    genres_recs = genres_recs.reset_index(drop=True)
    genre_match = (genres_recs == genre_asli).sum()
    precision_at_k = genre_match / top_k

    print(f"Precision@{top_k} untuk '{song_name}' oleh '{artist_name}': {precision_at_k:.2f}")
    return precision_at_k

"""Tahap ini menjalankan fungsi evaluasi sistem rekomendasi untuk lagu "Shape of You" oleh Ed Sheeran dengan menghitung Precision@10, yaitu seberapa banyak dari 10 lagu rekomendasi teratas yang memiliki genre yang sama dengan lagu tersebut. Hasil evaluasi ini membantu menilai relevansi genre dari sistem rekomendasi yang telah dibangun."""

evaluate_recommendation("Shape of You", "Ed Sheeran", top_k=10);

"""- Hasil Precision@10 = 0.70 untuk lagu "Shape of You" oleh Ed Sheeran berarti bahwa dari 10 lagu yang direkomendasikan, sebanyak 7 lagu memiliki genre yang sama dengan lagu tersebut (yaitu genre pop). Ini menunjukkan bahwa sistem rekomendasi cukup berhasil dalam memberikan saran lagu yang relevan secara genre, meskipun masih ada 3 lagu yang tidak segenre. Nilai ini menunjukkan performa yang cukup baik, tetapi masih bisa ditingkatkan untuk mencapai rekomendasi yang lebih konsisten dalam genre.

Tahap ini melakukan evaluasi Precision@K untuk setiap lagu dalam daftar song_list, lalu menggabungkan hasilnya ke dalam sebuah DataFrame. Selain itu, fungsi ini menghitung rata-rata Precision@K (Mean Precision@K) dari seluruh lagu yang berhasil dievaluasi. Ini berguna untuk mendapatkan gambaran umum seberapa baik sistem rekomendasi dalam mempertahankan konsistensi genre di antara lagu-lagu yang disarankan.
"""

def batch_evaluate_recommendation(song_list, top_k=10):
    precisions = []

    for song_name, artist_name in song_list:
        try:
            p = evaluate_recommendation(song_name, artist_name, top_k)
            if p is not None:
                precisions.append({
                    'track_name': song_name,
                    'track_artist': artist_name,
                    'precision': p
                })
        except Exception as e:
            print(f"Error evaluating {song_name} - {artist_name}: {e}")

    result_df = pd.DataFrame(precisions)
    mean_precision = result_df['precision'].mean()
    print(f"\nðŸŽ¯ Mean Precision@{top_k} untuk {len(result_df)} lagu: {mean_precision:.2f}")
    return result_df

"""Tahap ini membantu melihat secara visual perbandingan kualitas rekomendasi antar lagu."""

def plot_precision_scores(result_df):
    plt.figure(figsize=(10, 6))
    sns.barplot(x='precision', y='track_name', data=result_df, palette='viridis')
    plt.xlabel('Precision@K')
    plt.ylabel('Track')
    plt.title('Precision@K per Lagu')
    plt.xlim(0, 1)
    plt.tight_layout()
    plt.show()

"""Tahap ini melakukan **evaluasi batch Precision\@10** untuk lima lagu contoh, lalu **menampilkan hasilnya dalam bentuk visualisasi bar chart**.

Langkah ini bertujuan untuk:

* Mengukur sejauh mana sistem merekomendasikan lagu-lagu dengan **genre yang sama** (genre match) untuk tiap lagu input.
* **Membandingkan performa rekomendasi antar lagu** secara visual, sehingga dapat dengan mudah diidentifikasi lagu mana yang memperoleh rekomendasi paling relevan (precision tinggi) dan mana yang tidak.

"""

sample_songs = [
    ("Shape of You", "Ed Sheeran"),
    ("Blinding Lights", "The Weeknd"),
    ("Someone Like You", "Adele"),
    ("Happier", "Marshmello"),
    ("bad guy", "Billie Eilish"),
]

# Evaluasi batch
results = batch_evaluate_recommendation(sample_songs, top_k=10)

# Plot hasilnya
plot_precision_scores(results)

"""## ðŸ“ˆ Evaluasi Batch dan Visualisasi

### Batch Evaluation Strategy

**Mengapa Batch Evaluation?**
- **Statistical Significance**: Evaluasi single song bisa bias
- **Overall Performance**: Mengukur performa sistem secara keseluruhan
- **Comparative Analysis**: Membandingkan performa across different songs/genres

### Sample Songs Selection:
Memilih 5 lagu populer dari berbagai genre:
- **Diversity**: Representasi berbagai genre dan karakteristik
- **Popularity**: Lagu-lagu yang dikenal luas untuk interpretability
- **Balance**: Mix antara male/female artists, tempo, era

Sistem rekomendasi berhasil memberikan hasil yang cukup relevan dengan rata-rata Precision@10 sebesar 0.70. Artinya, 7 dari 10 lagu teratas umumnya memiliki genre yang sama dengan lagu input. Meski menunjukkan performa tinggi pada beberapa lagu seperti "Happier" dan "Blinding Lights", sistem masih perlu diperbaiki untuk lagu dengan genre yang lebih bervariasi. Evaluasi ini menunjukkan bahwa pendekatan content-based cukup efektif, namun akan lebih baik jika dikombinasikan dengan pendekatan lain seperti hybrid filtering untuk hasil yang lebih personal dan beragam.
"""